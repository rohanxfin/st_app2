
d = {'Audi': {'A3': ['35 TDI Premium[2014-2017]'],
  'A4': ['35 TDI Premium[2013-2016]', 'Premium Plus 40 TFSI'],
  'A6': ['2.0 TDI Premium[2011-2015]',
   '35 TDI Matrix[2015-2019]',
   'Premium Plus 45 TFSI',
   'Technology 45 TFSI'],
  'Q3': ['2.0 TDI quattro Premium[2012-2015]',
   '30 TFSI Premium[2017-2020]',
   '35 TDI Premium[2012-2015]'],
  'Q7 [2010 - 2015]': ['45 TDI Technology Pack']},
 'BMW': {'3 Series': ['320d Luxury Line'],
  'X1': ['sDrive20d', 'sDrive20d[2010-2012]'],
  'X3': ['xDrive 20d Luxury Line[2018-2022]', 'xDrive-20d xLine[2014-2018]'],
  'X5': ['M[2014-2019]',
   'xDrive 30d',
   'xDrive 30d[2012-2014]',
   'xDrive30d xLine',
   'xDrive40i M Sport'],
  'X7': ['xDrive40i M Sport'],
  'iX': ['xDrive 40']},
 'Ford': {'Endeavour': ['Titanium 3.2 4x4 AT[2016-2019]',
   'Titanium Plus 2.0 4x4 AT'],
  'Mustang': ['GT Fastback 5.0L v8']},
 'Honda': {'Amaze': ['1.2 S i-VTEC[2013-2016]', 'VX CVT 1.2 Petrol [2021]'],
  'BR-V': ['V CVT Petrol'],
  'Brio': ['S MT', 'VX AT'],
  'City': ['1.5 V MT[2011-2014]', 'E[2014-2017]', 'ZX Petrol CVT'],
  'Jazz': ['S Petrol[2015-2018]', 'V', 'V Petrol[2015-2018]'],
  'Mobilio': ['S Petrol'],
  'WR-V': ['VX MT Diesel',
   'VX MT Diesel[2017-2020]',
   'VX MT Petrol',
   'VX MT Petrol[2017-2020]']},
 'Hyundai': {'Aura': ['S 1.2 CNG'],
  'Creta': ['1.4 S[2015-2017]',
   '1.6 SX Plus AT Petrol[2015-2017]',
   '1.6 SX[2015-2017]',
   'E 1.5 Diesel',
   'E Plus 1.4 CRDI[2017-2018]',
   'E Plus 1.6 Petrol[2017-2018]',
   'EX 1.5 Petrol',
   'S 1.5 Petrol',
   'SX (O) 1.5 Diesel',
   'SX 1.5 Diesel[2020-2023]',
   'SX 1.5 Petrol',
   'SX 1.6 AT CRDi[2018-2019]',
   'SX 1.6 AT Petrol[2018-2019]',
   'SX 1.6 Petrol[2018-2019]',
   'SX Plus 1.6  Petrol[2017-2018]',
   'SX Plus 1.6 AT CRDI[2017-2018]'],
  'Elantra': ['SX (O) 2.0 AT'],
  'Elite i20': ['Asta 1.2',
   'Asta 1.2 (O)',
   'Asta 1.2[2014-2015]',
   'Asta 1.2[2017-2018]',
   'Magna 1.2',
   'Magna 1.2[2014-2015]',
   'Sportz 1.2',
   'Sportz 1.2[2014-2015]',
   'Sportz 1.2[2017-2018]',
   'Sportz 1.2[2019-2020]',
   'Sportz 1.4'],
  'Eon': ['Era +', 'Magna +'],
  'Grand i10': ['Asta 1.2 Kappa VTVT',
   'Asta AT 1.2 Kappa VTVT [2013-2016][2013-2017]',
   'Magna 1.2 Kappa VTVT',
   'Magna AT 1.2 Kappa VTVT',
   'Sportz (O) 1.2 Kappa VTVT [2017-2018]',
   'Sportz (O) AT 1.2 Kappa VTVT [2017-2018]',
   'Sportz 1.2 Kappa VTVT',
   'Sportz AT 1.2 Kappa VTVT'],
  'Santro': ['Sportz'],
  'Venue': ['S 1.2 Petrol',
   'SX (O) 1.0 Turbo iMT',
   'SX 1.0 Turbo',
   'SX 1.2 Petrol',
   'SX 1.5 CRDi',
   'SX Plus 1.0 Turbo DCT'],
  'Verna': ['i[2006-2010]'],
  'Xcent': ['E', 'SX'],
  'i10': ['Magna'],
  'i20': ['Magna 1.2[2012-2014]'],
  'i20 Active': ['1.2 S']},
 'Jeep': {'Compass': ['Limited (O) 2.0 Diesel',
   'Limited 2.0 Diesel[2017-2021]',
   'Longitude (O) 2.0 Diesel']},
 'Kia': {'Carnival': ['Limousine Plus 7 STR', 'Prestige 7 STR'],
  'Seltos': ['GTX Plus 1.4[2019-2022]',
   'GTX Plus 1.5 Diesel AT',
   'GTX Plus AT 1.5 Diesel [2019-2020][2019-2022]',
   'HTK 1.5[2019-2022]',
   'HTK Plus 1.5 Diesel AT',
   'HTK Plus 1.5[2019-2022]',
   'HTX 1.5[2019-2022]',
   'HTX IVT 1.5 [2019-2020][2019-2022]']},
 'MG': {'Hector': ['Sharp 1.5 DCT Petrol',
   'Sharp 1.5 DCT Petrol[2019-2021]',
   'Sharp 2.0 Diesel[2019-2021]'],
  'ZS EV': ['Exclusive']},
 'Mahindra': {'Alturas G4': ['4WD AT'],
  'TUV300': ['T8', 'T8[2015-2019]'],
  'Thar': ['CRDe 4x4 AC[2014-2020]',
   'LX Convertible Petrol AT',
   'LX Hard Top Diesel AT',
   'LX Hard Top Diesel AT 4WD',
   'LX Hard Top Diesel AT 4WD [2023]',
   'LX Hard Top Diesel MT 4WD',
   'LX Hard Top Diesel MT RWD',
   'LX Hard Top Petrol AT',
   'LX Hard Top Petrol AT 4WD',
   'LX Hard Top Petrol MT'],
  'XUV300': ['W8 (O) 1.2 Petrol', 'W8 (O) 1.5 Diesel'],
  'XUV500': ['W10[2015-2018]',
   'W11',
   'W6[2011-2015]',
   'W6[2015-2018]',
   'W7',
   'W8[2011-2015]',
   'W9']},
 'Maruti Suzuki': {'Alto 800': ['LXi', 'Lx[2012-2016]', 'VXi'],
  'Baleno': ['Alpha 1.2[2015-2019]',
   'Alpha[2019-2022]',
   'Delta 1.2[2015-2019]',
   'Zeta 1.2[2015-2019]',
   'Zeta[2019-2022]'],
  'Brezza': ['LXi', 'VXi', 'ZXi', 'ZXi Plus'],
  'Celerio': ['VXi', 'VXi AMT', 'ZXi'],
  'Ciaz': ['Alpha 1.4 AT[2017-2018]',
   'Alpha Hybrid 1.5 AT [2018-2020]',
   'Alpha Hybrid 1.5 [2018-2020]',
   'VXi[2014-2017]',
   'ZXI+[2014-2017]',
   'ZXi[2014-2017]'],
  'Eeco': ['5 STR AC', '5 STR[2010-2022]'],
  'Ertiga': ['VDI SHVS[2015-2018]',
   'VXI[2015-2018]',
   'VXi',
   'VXi (O) CNG',
   'VXi CNG',
   'VXi[2018-2022]',
   'ZXi',
   'ZXi Plus',
   'ZXi[2018-2022]'],
  'Ignis': ['Delta 1.2 AMT', 'Delta 1.2 MT', 'Zeta 1.2 AMT', 'Zeta 1.2 MT'],
  'S-Cross': ['Zeta 1.3', 'Zeta 1.3[2014-2017]'],
  'S-Presso': ['VXi'],
  'Swift': ['LXi',
   'VDi[2014-2018]',
   'VXi',
   'VXi AMT',
   'ZDi[2014-2018]',
   'ZXi',
   'ZXi Plus'],
  'Swift DZire': ['VDI[2011-2015]', 'VXI[2011-2015]'],
  'Vitara Brezza': ['VDi[2016-2020]', 'ZDi[2016-2020]'],
  'Wagon R': ['LXI 1.0', 'LXI 1.0 CNG', 'VXI 1.0'],
  'XL6': ['Alpha AT Petrol',
   'Alpha MT Petrol',
   'Zeta AT Petrol',
   'Zeta MT Petrol']},
 'Renault': {'Kiger': ['RXZ MT', 'RXZ Turbo CVT'],
  'Kwid': ['1.0 RXT [2016-2019][2015-2019]',
   'CLIMBER 1.0 AMT',
   'RXT Opt [2015-2019][2015-2019]',
   'RXT [2015-2019][2015-2019]'],
  'Triber': ['RXL', 'RXT', 'RXZ']},
 'Skoda': {'Kodiaq': ['L&K', 'Style'],
  'Kushaq': ['Style 1.0L TSI AT[2021-2023]'],
  'Rapid': ['Ambition 1.5 TDI', 'Style 1.5 TDI', 'Style 1.6 MPI'],
  'Slavia': ['Style 1.0L TSI AT', 'Style 1.5L TSI DSG'],
  'Superb': ['L&K']},
 'Tata': {'Altroz': ['XZ Petrol'],
  'Harrier': ['XT[2019-2023]', 'XZ[2019-2023]'],
  'Hexa': ['XT 4x2 7 STR', 'XTA 4x2 7 STR'],
  'Nano': ['Twist XT'],
  'Nexon': ['XM[2017-2020]', 'XM[2020-2023]', 'XZ[2017-2020]'],
  'Safari': ['XZ[2021-2023]'],
  'Tiago': ['Revotron XZA [2017-2019][2016-2020]',
   'XE',
   'XM',
   'XT',
   'XZ',
   'XZ Plus',
   'XZA'],
  'Tigor': ['XZ', 'XZ Plus']},
 'Toyota': {'Camry': ['Hybrid'],
  'Corolla Altis': ['G Petrol[2014-2017]',
   'G[2014-2017]',
   'VL AT Petrol[2014-2017]'],
  'Etios': ['GD', 'G[2010-2013]'],
  'Fortuner': ['2.8 4x2 MT[2016-2021]',
   '2.8 4x4 AT[2016-2021]',
   '3.0 4x2 AT[2012-2016]',
   '3.0 4x2 MT[2012-2016]',
   '4X2 AT 2.8 Diesel',
   '4X4 AT 2.8 Diesel'],
  'Glanza': ['E', 'V'],
  'Innova Crysta': ['2.4 VX 7 STR[2016-2020]',
   '2.4 ZX 7 STR[2016-2020]',
   '2.8 GX AT 7 STR [2016-2020][2016-2020]',
   '2.8 GX AT 8 STR [2016-2020][2016-2020]',
   '2.8 ZX AT 7 STR [2016-2020][2016-2020]',
   'GX 2.4 AT 7 STR[2020-2023]',
   'ZX 2.4 AT 7 STR[2020-2023]'],
  'Urban Cruiser': ['Premium Grade AT']},
 'Volkswagen': {'Ameo': ['Comfortline 1.2L (P)',
   'Highline Plus 1.5L AT (D)16 Alloy'],
  'Polo': ['GT'],
  'Taigun': ['GT Plus 1.5 TSI DSG',
   'Highline 1.0 TSI AT',
   'Topline 1.0 TSI AT',
   'Topline 1.0 TSI MT'],
  'Tiguan': ['Highline TDI[2017-2020]'],
  'Vento': ['Highline 1.2 (P) AT',
   'Highline Diesel[2010-2012]',
   'Highline Plus 1.2 (P) AT']}}

import streamlit as st
import joblib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# -----------------------------------------------------------------------------
# 1) Define Custom Transform Function
# -----------------------------------------------------------------------------
def log1p_transform(x):
    """
    Custom log1p transform function used in the model's preprocessing pipeline.
    """
    return np.log1p(x)

MODEL_PATH_CAT = 'best_pipeline.joblib'

# Ensure this matches your saved pipeline's filename
DATASET_PATH = 'new_training_data.csv'

# Load the dataset with proper error handling
try:
    df = pd.read_csv(DATASET_PATH)
    required_columns = {'Make', 'Model', 'Variant', 'Age', 'Distance_numeric', 'Price_numeric'}
    if not required_columns.issubset(df.columns):
        missing = required_columns - set(df.columns)
        st.error(f"The dataset is missing required columns: {missing}")
        st.stop()
except FileNotFoundError:
    st.error(f"Dataset file not found at path: {DATASET_PATH}")
    st.stop()
except pd.errors.EmptyDataError:
    st.error("The dataset file is empty.")
    st.stop()
except pd.errors.ParserError:
    st.error("Error parsing the dataset file. Please check its format.")
    st.stop()
except Exception as e:
    st.error(f"An unexpected error occurred while loading the dataset: {e}")
    st.stop()

# -----------------------------------------------------------------------------
# 3) Helper Functions
# -----------------------------------------------------------------------------
def get_age_bracket(age):
    """
    Returns a label based on the age bucket.
    """
    if age < 2:
        return '0-2'
    elif age < 4:
        return '2-4'
    elif age < 6:
        return '4-6'
    elif age < 8:
        return '6-8'
    elif age < 10:
        return '8-10'
    elif age < 12:
        return '10-12'
    elif age < 15:
        return '12-15'
    else:
        return '15+'

def get_mileage_bracket(mileage):
    """
    Returns a label based on the odometer bucket.
    """
    if mileage < 30000:
        return '0-30k'
    elif mileage < 60000:
        return '30k-60k'
    elif mileage < 100000:
        return '60k-100k'
    elif mileage < 150000:
        return '100k-150k'
    else:
        return '150k+'

def get_nearest_age_subset(df, make, model, variant, age, min_samples=5, max_delta=5):
    """
    Selects a subset of the dataframe based on the nearest age group.
    Starts with the same age, then expands the range by ±1, ±2, etc., until
    at least min_samples are found or max_delta is reached.
    """
    subset = df[
        (df['Make'] == make) &
        (df['Model'] == model) &
        (df['Variant'] == variant)
    ]

    if subset.empty:
        return subset  # Empty subset

    max_age = subset['Age'].max()

    # If input age exceeds max_age, return the entire subset to handle depreciation
    if age > max_age:
        return subset

    # Initialize delta
    delta = 0
    while delta <= max_delta:
        age_min = age - delta
        age_max = age + delta
        # Ensure age_min is not negative
        age_min = max(age_min, 0)
        subset_age = subset[
            (subset['Age'] >= age_min) &
            (subset['Age'] <= age_max)
        ]
        if len(subset_age) >= min_samples:
            return subset_age
        delta += 1

    # If not enough samples even after max_delta, return the closest possible subset
    return subset[
        (subset['Age'] >= max(age - max_delta, 0)) &
        (subset['Age'] <= min(age + max_delta, max_age))
    ]


# # guardrails.py

import numpy as np

import numpy as np
import pandas as pd

# def get_age_bracket(age):
#     """
#     Example bracket function – adjust to suit your logic.
#     E.g., every 5 years is a bracket: 0-5, 6-10, 11-15, ...
#     """
#     return int(age // 5) * 5

def get_neighbor_brackets(df, current_bracket, num_buckets=2):
    """
    Given the DataFrame `df` that has a column 'Age_Bracket',
    and a 'current_bracket', find the next `num_buckets` brackets
    above and below in sorted order.
    Returns a list of bracket values, including the current one.
    """
    all_brackets = sorted(df['Age_Bracket'].unique())
    if current_bracket not in all_brackets:
        # If your bracket isn't in the data at all, just return empty
        return []
    
    idx = all_brackets.index(current_bracket)
    
    # Grab up to `num_buckets` previous, the current bracket, and up to `num_buckets` next
    lower_idx = max(0, idx - num_buckets)
    upper_idx = min(len(all_brackets), idx + num_buckets + 1)
    
    neighbor_brackets = all_brackets[lower_idx:upper_idx]
    return neighbor_brackets

def get_top_n_and_bottom_n(df, brackets, top_n=2, bottom_n=2):
    """
    From the rows whose Age_Bracket is in `brackets`,
    gather the top_n highest prices and bottom_n lowest prices.
    Return (list_of_bottom_values, list_of_top_values).
    """
    subset = df[df['Age_Bracket'].isin(brackets)]
    if subset.empty:
        return [], []
    
    sorted_prices = sorted(subset['Price_numeric'])
    
    # Bottom N
    bottom_vals = sorted_prices[:bottom_n]
    # Top N
    top_vals = sorted_prices[-top_n:] if len(sorted_prices) >= top_n else sorted_prices
    
    return bottom_vals, top_vals

def apply_guardrails(age, distance, fuel_type, city, avg_prediction, df_subset,
                     depreciation_rate=0.05,   # Default 5% annual depreciation
                     min_floor=50000,
                     appreciation_rate=0.05):  # 5% annual appreciation
    """
    Applies guardrails on the average prediction and returns a final price,
    with added bucket-based outlier handling.
    """
    # 1) Regulatory constraints for certain regions and fuel types
    if (fuel_type.lower() == 'diesel' and age > 10 and city.lower() in ['delhi', 'gurgaon', 'noida']):
        return None
    if (fuel_type.lower() == 'petrol' and age > 15 and city.lower() in ['delhi', 'gurgaon', 'noida']):
        return None

    # Work on a copy of the subset
    df_subset = df_subset.copy()
    df_subset['Age_Bracket'] = df_subset['Age'].apply(get_age_bracket)
    
    min_age_subset = df_subset['Age'].min()
    max_age_subset = df_subset['Age'].max()

    # -----------------------------------------------------------------
    # Start with the raw average model prediction
    # -----------------------------------------------------------------
    clamped_price = avg_prediction

    # -----------------------------------------------------------------
    # EXACT age data
    # -----------------------------------------------------------------
    same_age_data = df_subset[df_subset['Age'] == age]
    if not same_age_data.empty:
        if len(same_age_data) >= 5:
            # (Unchanged logic) clamp between 5th and 95th percentile
            p_low, p_high = np.percentile(same_age_data['Price_numeric'], [5, 95])
            clamped_price = np.clip(avg_prediction, p_low*0.98, p_high*1.02)
        else:
            # use the mean if <5 data points
            clamped_price = same_age_data['Price_numeric'].mean()

    else:
        # -----------------------------------------------------------------
        # Car is NEWER (younger) than the dataset's minimum age
        # -----------------------------------------------------------------
        if age < min_age_subset:
            younger_data = df_subset[df_subset['Age'] == min_age_subset]
            if not younger_data.empty:
                if len(younger_data) >= 5:
                    base_price = younger_data['Price_numeric'].quantile(0.75)
                else:
                    base_price = younger_data['Price_numeric'].mean()
                # Appreciate for years below the min known age
                years_below = int(min_age_subset - age)
                clamped_price = base_price * ((1 + appreciation_rate) ** years_below)
            else:
                clamped_price = avg_prediction

        # -----------------------------------------------------------------
        # Car's age is within [min_age_subset, max_age_subset] range
        # -----------------------------------------------------------------
        elif age <= max_age_subset and len(df_subset) >= 1:
            if len(df_subset) >= 5:
                # Basic percentile clamp (unchanged)
                lower_p = 25 if len(df_subset) < 20 else 5
                upper_p = 75 if len(df_subset) < 20 else 95
                p_low, p_high = np.percentile(df_subset['Price_numeric'], [lower_p, upper_p])
                clamped_price = np.clip(avg_prediction, p_low*0.97, p_high*1.03)
            else:
                clamped_price = df_subset['Price_numeric'].mean()

        # -----------------------------------------------------------------
        # Car is OLDER than the dataset's maximum age
        # -----------------------------------------------------------------
        if age > max_age_subset and len(df_subset) > 0:
            older_data = df_subset[df_subset['Age'] == max_age_subset]
            if not older_data.empty:
                if len(older_data) >= 5:
                    base_price = older_data['Price_numeric'].quantile(0.25)
                else:
                    base_price = older_data['Price_numeric'].mean()

                # Possibly adjust depreciation
                if fuel_type.lower() == 'diesel' and city.lower() in ['delhi', 'gurgaon', 'noida']:
                    depreciation_rate = 0.07
                elif fuel_type.lower() == 'petrol' and age > 15:
                    depreciation_rate = 0.05

                years_beyond = int(age - max_age_subset)
                clamped_price = base_price * ((1 - depreciation_rate) ** years_beyond)
            else:
                clamped_price = avg_prediction

    # -----------------------------------------------------------------
    # ADDITIONAL STEP: Use bucket-based top/bottom logic to further
    # clamp outliers in the final price estimate
    # -----------------------------------------------------------------
    this_bracket = get_age_bracket(age)
    
    # Find neighbor brackets (e.g., ±2 from current bracket)
    neighbor_brackets = get_neighbor_brackets(df_subset, this_bracket, num_buckets=2)
    
    if neighbor_brackets:
        bottom_vals, top_vals = get_top_n_and_bottom_n(df_subset, neighbor_brackets, top_n=2, bottom_n=2)
        if bottom_vals and top_vals:
            # For a simple approach, average the bottom and top sets to define robust bounds
            robust_low_bound = np.mean(bottom_vals)
            robust_high_bound = np.mean(top_vals)

            # Add a little margin if needed:
            robust_low_bound *= 0.95
            robust_high_bound *= 1.05
            
            # Re-clamp
            clamped_price = np.clip(clamped_price, robust_low_bound, robust_high_bound)

    # -----------------------------------------------------------------
    # Final floor: ensure we never go below a minimum floor
    # -----------------------------------------------------------------
    final_price = max(clamped_price, min_floor)
    return final_price


# def apply_guardrails(age, distance, fuel_type, city, avg_prediction, df_subset,
#                      depreciation_rate=0.05,   # Default 5% annual depreciation
#                      min_floor=50000,
#                      appreciation_rate=0.05):  # 5% annual appreciation
#     """
#     Applies guardrails on the average prediction and returns a final price.
#     Prioritizes exact age data if it exists.
#     """
#     # 1) Regulatory constraints for certain regions and fuel types
#     if (fuel_type.lower() == 'diesel' and age > 10 and city.lower() in ['delhi', 'gurgaon', 'noida']):
#         return None
#     if (fuel_type.lower() == 'petrol' and age > 15 and city.lower() in ['delhi', 'gurgaon', 'noida']):
#         return None

#     # Work on a copy of the subset
#     df_subset = df_subset.copy()
#     df_subset['Age_Bracket'] = df_subset['Age'].apply(get_age_bracket)
#     min_age_subset = df_subset['Age'].min()
#     max_age_subset = df_subset['Age'].max()

#     # Final clamped price starts from the raw average model prediction
#     clamped_price = avg_prediction

#     # -----------------------------------------------
#     # 0) Check if data for the EXACT same age exists
#     # -----------------------------------------------
#     same_age_data = df_subset[df_subset['Age'] == age]
#     if not same_age_data.empty:
#         # If we have at least 5 data points for this exact age,
#         # clamp between a chosen percentile range:
#         if len(same_age_data) >= 5:
#             # Example: between the 5th and 95th percentile
#             p_low, p_high = np.percentile(same_age_data['Price_numeric'], [5, 95])
#             clamped_price = np.clip(avg_prediction,
#                                     p_low * 0.95,
#                                     p_high * 1.05)
#         else:
#             # Otherwise, use the mean if fewer than 5 data points
#             clamped_price = same_age_data['Price_numeric'].mean()

#     else:
#         # -----------------------------------------------------------------
#         # 1) Cars NEWER (younger) than the dataset's minimum age
#         # -----------------------------------------------------------------
#         if age < min_age_subset:
#             # Subset for the minimum age in the dataset
#             younger_data = df_subset[df_subset['Age'] == min_age_subset]
#             if not younger_data.empty:
#                 # Use 75th percentile or mean
#                 if len(younger_data) >= 5:
#                     base_price = younger_data['Price_numeric'].quantile(0.75)
#                 else:
#                     base_price = younger_data['Price_numeric'].mean()

#                 # Years below the min age => appreciate 5% per year
#                 years_below = int(min_age_subset - age)
#                 clamped_price = base_price * ((1 + appreciation_rate) ** years_below)
#             else:
#                 # If no rows even at the min age, fallback to raw avg_prediction
#                 clamped_price = avg_prediction

#         # -----------------------------------------------------------------
#         # 2) Cars within the dataset age range (but no exact match above)
#         # -----------------------------------------------------------------
#         elif age <= max_age_subset and len(df_subset) >= 1:
#             # If we have enough data overall, clamp between some percentile
#             if len(df_subset) >= 5:
#                 # You can pick which percentile range you want
#                 lower_p = 25 if len(df_subset) < 20 else 5
#                 upper_p = 75 if len(df_subset) < 20 else 95
#                 p_low, p_high = np.percentile(df_subset['Price_numeric'], [lower_p, upper_p])

#                 clamped_price = np.clip(
#                     avg_prediction,
#                     p_low  * 0.97,
#                     p_high * 1.03
#                 )
#             else:
#                 # If only a few data points total, use the mean
#                 clamped_price = df_subset['Price_numeric'].mean()

#         # -----------------------------------------------------------------
#         # 3) Cars OLDER than the dataset maximum age
#         # -----------------------------------------------------------------
#         if age > max_age_subset and len(df_subset) > 0:
#             # Subset for the maximum age in the dataset
#             older_data = df_subset[df_subset['Age'] == max_age_subset]
#             if not older_data.empty:
#                 # Use 25th percentile or mean
#                 if len(older_data) >= 5:
#                     base_price = older_data['Price_numeric'].quantile(0.25)
#                 else:
#                     base_price = older_data['Price_numeric'].mean()

#                 # Potentially adjust depreciation for special cases
#                 if fuel_type.lower() == 'diesel' and city.lower() in ['delhi', 'gurgaon', 'noida']:
#                     depreciation_rate = 0.07  # Overwrite default 5%
#                 elif fuel_type.lower() == 'petrol' and age > 15:
#                     depreciation_rate = 0.05

#                 years_beyond = int(age - max_age_subset)
#                 clamped_price = base_price * ((1 - depreciation_rate) ** years_beyond)
#             else:
#                 clamped_price = avg_prediction

#     # -----------------------------------------------------------
#     # Ensure we never go below the minimum floor
#     # -----------------------------------------------------------
#     final_price = max(clamped_price, min_floor)
#     return final_price

def find_closest_cars(make, model, variant, age, distance, df):
    """
    Returns up to 10 closest cars in the dataset based on the same M-M-V.
    """
    filtered = df[
        (df['Make'] == make) &
        (df['Model'] == model) &
        (df['Variant'] == variant)
    ]

    if filtered.empty:
        return pd.DataFrame()

    filtered = filtered.copy()
    filtered['Age_Diff'] = abs(filtered['Age'] - age)
    filtered['Odom_Diff'] = abs(filtered['Distance_numeric'] - distance)
    closest_cars = filtered.sort_values(by=['Age_Diff', 'Odom_Diff']).head(10)
    return closest_cars[['Make', 'Model', 'Variant', 'Age', 'Distance_numeric', 'Price_numeric']]

# -----------------------------------------------------------------------------
# 4) Streamlit Application Layout and Inputs
# -----------------------------------------------------------------------------
st.title("Used Car Price Prediction App with M-M-V Guardrails")
st.write("""
This application predicts the price of a used car based on various features.
**Guardrails** are applied per Make-Model-Variant (M-M-V) subset to clamp unrealistic values.
For cars older than the dataset's maximum age for their M-M-V, a constant depreciation rate is applied.
""")

# Sidebar Inputs
st.sidebar.header("Enter Car Details")

# Define the hierarchical dictionary for Make, Model, Variant
# (Ensure this matches your dataset and model training)
# Example structure, replace with your actual data
# Select Make
selected_make = st.sidebar.selectbox("Select Make", options=list(d.keys()) if d else [])

# Select Model based on Make
if selected_make:
    selected_model = st.sidebar.selectbox("Select Model", options=list(d[selected_make].keys()))
else:
    selected_model = None

# Select Variant based on Model
if selected_model:
    selected_variant = st.sidebar.selectbox("Select Variant", options=d[selected_make][selected_model])
else:
    selected_variant = None

# Select City
selected_city = st.sidebar.selectbox(
    "City",
    [
        'Ahmedabad', 'Bangalore', 'Chennai', 'Gurgaon', 'Hyderabad', 'Kolkata',
        'Pune', 'Delhi', 'Panchkula', 'Ludhiana', 'Kharar', 'Coimbatore',
        'Noida', 'Ghaziabad', 'Lucknow', 'Mumbai', 'Thane', 'Mohali',
        'Kharagpur', 'Chandigarh', 'Ambala', 'Navi', 'Faridabad', 'Meerut',
        'Sangli', 'Surat', 'Mysore', 'Gulbarga', 'Ranga', 'Vadodara', 'Howrah'
    ]
)

# Select Transmission
selected_transmission = st.sidebar.selectbox("Transmission", ['Manual', 'Automatic'])

# Select Fuel Type
selected_fuel_type = st.sidebar.selectbox("Fuel Type", ['Petrol', 'Diesel', 'CNG'])


# Numeric Inputs
age = st.sidebar.number_input("Age (years)", min_value=0, max_value=50, value=5, step=1)
distance = st.sidebar.number_input("Odometer Reading (km)", min_value=0, max_value=500000, value=40000, step=1000)

# Dynamic ± range slider
range_percentage = st.sidebar.slider("Confidence Range (%)", 1, 20, 5)

# -----------------------------------------------------------------------------
# 5) Prediction Function
# -----------------------------------------------------------------------------
def predict_price_from_multiple_models(age, distance, make, car_model, variant, city, transmission, fuel_type ):
    """
    Get raw model predictions from multiple models.
    """
    # Avoid division by zero

    input_data = pd.DataFrame([{
        'Make': make,
        'Model': car_model,
        'Transmission': transmission,
        'Fuel Type': fuel_type,
        'City': city,
        'Distance_numeric': distance,
        'Age': age,
        'Variant': variant
    }])

    predictions = {}
    models = {
        "CatBoost": MODEL_PATH_CAT
    }


    for model_name, model_path in models.items():
        try:
            model = joblib.load(model_path)
            prediction = model.predict(input_data)
            predictions[model_name] = prediction[0]
        except Exception as e:
            st.error(f"Error during prediction with {model_name}: {e}")

    return predictions

# -----------------------------------------------------------------------------
# 6) Main Button: Generate Prediction & Apply Guardrails
# -----------------------------------------------------------------------------
if st.button("Predict Price"):
    if not all([selected_make, selected_model, selected_variant, selected_city, selected_transmission, selected_fuel_type]):
        st.error("Please fill in all the car details.")
    else:
        # Get predictions from different models
        raw_predictions = predict_price_from_multiple_models(
            age=age,
            distance=distance,
            make=selected_make,
            car_model=selected_model,  # Renamed parameter to avoid shadowing
            variant=selected_variant,
            city=selected_city,
            transmission=selected_transmission,
            fuel_type=selected_fuel_type,

        )

        if not raw_predictions:
            st.error("An error occurred during prediction. Please check your inputs.")
        else:
            # Calculate the average prediction
            avg_prediction = np.mean(list(raw_predictions.values()))
            st.success(f"Average Predicted Price: ₹{round(avg_prediction)}")

            # Apply guardrails on the average prediction
            subset_mmv = get_nearest_age_subset(
                df=df,
                make=selected_make,
                model=selected_model,
                variant=selected_variant,
                age=age,
                min_samples=5,   # Minimum required samples
                max_delta=5      # Maximum age difference to consider
            )

            if subset_mmv.empty:
                st.error("No data available for the selected Make-Model-Variant.")
                st.success(f"Average Predicted Price: ₹{round(avg_prediction)}")
                # Even if subset is empty, you might still want to display the raw average
                # Depending on your requirements
                # Optionally, you can decide to stop here
            else:
                # Apply guardrails to the average prediction
                guarded_price = apply_guardrails(
                    age=age,
                    distance=distance,
                    fuel_type=selected_fuel_type,
                    city=selected_city,
                    avg_prediction=avg_prediction,
                    df_subset=subset_mmv,
                    depreciation_rate=0.04,  # 4% depreciation rate per year beyond max age
                    min_floor=40000           # ₹40,000 minimum floor
                )

                if guarded_price is None:
                    st.error("Cannot predict a valid price under current regulations/constraints.")
                else:
                    st.success(f"Guarded Average Predicted Price: ₹{round(guarded_price)}")

                    # Calculate dynamic ± range for the guarded price
                    lower_bound = guarded_price * (1 - range_percentage / 100)
                    upper_bound = guarded_price * (1 + range_percentage / 100)
                    st.write(f"Price Range (±{range_percentage}%): ₹{round(lower_bound)} - ₹{round(upper_bound)}")

                    similar_cars = find_closest_cars(selected_make, selected_model, selected_variant, age, distance, df)
                    if similar_cars.empty:
                        st.write("No similar cars found in the dataset for this M-M-V.")
                    else:
                        st.write("Closest Cars (based on Age & Odometer):")
                        st.dataframe(similar_cars)



                    # Optional: Plot Age vs. Price for M-M-V subset with only the average point
                    if not subset_mmv.empty:
                        fig, ax = plt.subplots(figsize=(8, 6))

                        # Scatter plot for dataset cars (same M-M-V)
                        mmv_subset = df[
                            (df['Make'] == selected_make) & 
                            (df['Model'] == selected_model) & 
                            (df['Variant'] == selected_variant)
                        ]
                        ax.scatter(
                            mmv_subset['Age'], 
                            mmv_subset['Price_numeric'], 
                            color='blue',  
                            alpha=0.5, 
                            label='Dataset Cars (Same M-M-V)'
                        )

                        # Plot the guarded average prediction
                        ax.scatter(
                            age, 
                            guarded_price, 
                            color='purple', 
                            s=200, 
                            zorder=5, 
                            marker='*', 
                            label='Guarded Average Prediction'
                        )

                        # Shade the ± range
                        ax.fill_between(
                            x=[age - 1, age + 1],  # Adjust x-range around the age
                            y1=lower_bound,
                            y2=upper_bound,
                            color='lightgreen', 
                            alpha=0.2,
                            label=f"±{range_percentage}% Range"
                        )

                        ax.set_xlabel("Age (Years)")
                        ax.set_ylabel("Price (₹)")
                        ax.set_title(f"Age vs. Price for {selected_make} {selected_model} {selected_variant}")
                        ax.legend()
                        st.pyplot(fig)
                    else:
                        st.write("No data to plot for this M-M-V subset.")
